{"version":3,"sources":["components/Blob.tsx","components/AgarIO.tsx","serviceWorker.ts","index.tsx"],"names":["Blob","props","className","cx","position","x","cy","y","r","fill","width","window","innerWidth","height","innerHeight","numberOfBlobs","AgarIO","useState","id","mainBlob","setMainBlob","mainBlobR","Array","map","value","index","getRandomNumber","getRandomPos","blobsPositions","setBlobsPositions","setPosition","svg","useRef","min","max","Math","random","getMagnitude","sqrt","useEffect","current","point","createSVGPoint","document","onmousemove","e","clientX","clientY","ontouchmove","touches","setPositionUpdater","forEach","pos","other","blobs","splice","callback","delay","savedCallback","setInterval","clearInterval","useInterval","pt","svgElement","screenCTM","getScreenCTM","loc","matrixTransform","inverse","normalized","magnitude","normalize","updatePosition","viewBox","ref","transform","blob","key","Boolean","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.ac2012fa.chunk.js","sourcesContent":["import * as React from \"react\";\r\nimport {BlobData} from \"../types\";\r\n\r\nconst Blob = (props: BlobData) => {\r\n    return <circle className={'blob'} cx={props.position.x} cy={props.position.y} r={props.r} fill={\"white\"}/>\r\n};\r\n\r\nexport default Blob;","import React, {RefObject, useEffect, useRef, useState} from 'react';\r\nimport Blob from \"./Blob\";\r\nimport {clearInterval, setInterval} from \"timers\";\r\nimport {BlobData, Position} from \"../types\";\r\n\r\nconst width = window.innerWidth;\r\nconst height = window.innerHeight;\r\nconst initialSizeMainBlob = 50;\r\nconst delay = 20;\r\nconst numberOfBlobs = 200;\r\n\r\nconst AgarIO = () => {\r\n    const [mainBlob, setMainBlob] = useState<BlobData>({\r\n        position: {\r\n            x: 0,\r\n            y: 0\r\n        },\r\n        r: initialSizeMainBlob,\r\n        id: 0\r\n    });\r\n    const [blobsPositions, setBlobsPositions] = useState<BlobData[]>(getRandomPos(width, height, initialSizeMainBlob));\r\n    const [position, setPosition] = useState();\r\n    const svg: RefObject<SVGSVGElement> = useRef(null);\r\n    useEffect(() => setPositionUpdater(), []);\r\n    useEffect(() => handleEatenBlobs());\r\n    useInterval(() => updatePosition(position), delay);\r\n\r\n    function handleEatenBlobs(): void {\r\n        blobsPositions.forEach((pos: BlobData, index: number) => {\r\n            if (eats(pos)) {\r\n                const blobs = blobsPositions;\r\n                blobs.splice(index, 1);\r\n                setBlobsPositions(blobs);\r\n            }\r\n        });\r\n    }\r\n\r\n    function useInterval(callback: any, delay: any) {\r\n        const savedCallback = useRef();\r\n        useEffect(() => {\r\n            savedCallback.current = callback;\r\n        }, [callback]);\r\n\r\n        useEffect(() => {\r\n            function tick() {\r\n                (savedCallback as any).current();\r\n            }\r\n\r\n            if (delay !== null) {\r\n                let id = setInterval(tick, delay);\r\n                return () => clearInterval(id);\r\n            }\r\n        }, [delay]);\r\n    }\r\n\r\n    function updatePosition(pt: DOMPoint): void {\r\n        const svgElement = svg.current;\r\n        if (svgElement) {\r\n            const screenCTM = svgElement.getScreenCTM();\r\n            if (screenCTM) {\r\n                const loc = pt.matrixTransform(screenCTM.inverse());\r\n                const normalized = normalize(loc.x - width / 2, loc.y - height / 2);\r\n                setMainBlob({\r\n                    ...mainBlob,\r\n                    position: {\r\n                        x: mainBlob.position.x + normalized.x,\r\n                        y: mainBlob.position.y + normalized.y\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    function setPositionUpdater(): void {\r\n        if (svg.current) {\r\n            let point = svg.current.createSVGPoint();\r\n            document.onmousemove = (e) => {\r\n                point.x = e.clientX;\r\n                point.y = e.clientY;\r\n            };\r\n            document.ontouchmove = (e) => {\r\n                point.x = e.touches[0].clientX;\r\n                point.y = e.touches[0].clientY;\r\n            };\r\n            setPosition(point);\r\n        }\r\n    }\r\n\r\n    function eats(other: BlobData): boolean {\r\n        const distance = getMagnitude(mainBlob.position.x - other.position.x, mainBlob.position.y - other.position.y);\r\n        if (distance < mainBlob.r + other.r) {\r\n            setMainBlob({...mainBlob, r: getMagnitude(mainBlob.r, other.r)});\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function getRandomPos(width: number, height: number, mainBlobR: number): BlobData[] {\r\n        return Array(numberOfBlobs).fill(0).map((value, index) => {\r\n            return {\r\n                position: {x: getRandomNumber(-2 * width, 2 * width), y: getRandomNumber(-2 * height, 2 * height)},\r\n                r: getRandomNumber(10, mainBlobR - 10),\r\n                id: index\r\n            }\r\n        });\r\n    }\r\n\r\n    function getRandomNumber(min: number, max: number): number {\r\n        return Math.random() * (max - min) + min;\r\n    }\r\n\r\n    function getMagnitude(x: number, y: number): number {\r\n        return Math.sqrt(x * x + y * y);\r\n    }\r\n\r\n    function normalize(x: number, y: number): Position {\r\n        let magnitude = getMagnitude(x, y);\r\n        if (magnitude > 0) {\r\n            magnitude = magnitude / 5;\r\n            return {x: x / magnitude, y: y / magnitude};\r\n        } else {\r\n            return {x: x, y: y}\r\n        }\r\n    }\r\n\r\n    const MainBlob = () => <Blob id={mainBlob.id} position={{x: mainBlob.position.x, y: mainBlob.position.y}}\r\n                                 r={mainBlob.r}/>;\r\n\r\n    return (\r\n        <svg viewBox={`0 0 ${width} ${height}`} ref={svg}>\r\n            <g className={'wrapper'}\r\n               transform={`translate(${width / 2}, ${height / 2}), scale(${initialSizeMainBlob / mainBlob.r})`}>\r\n                <g transform={`translate(${-mainBlob.position.x}, ${-mainBlob.position.y})`}>\r\n                    <MainBlob/>\r\n                    <g>{blobsPositions.map((blob: BlobData) =>\r\n                        <Blob id={blob.id} position={{\r\n                            x: blob.position.x,\r\n                            y: blob.position.y\r\n                        }} r={blob.r} key={blob.id}/>)}</g>\r\n                </g>\r\n            </g>\r\n        </svg>\r\n    );\r\n};\r\n\r\nexport default AgarIO;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport AgarIO from './components/AgarIO';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<AgarIO />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}